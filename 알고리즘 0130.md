# 알고리즘 01/30

- 슈더코드와 순서도 

- 좋은 코딩이란?

  

#### 시간 복잡도 (빅-오 표기법)

- n이 무한히 클때를 생각
  (ex, 3n+2 -> 3n -> n)
- 표기 방식은 위와 같이 n만 남을 경우  O(n)으로 표현
- log의 밑은 10이 아니라 2이다
- n**2 이상의 큰 수들은 여전히 시간 복잡도가 많이 크다.



## 배열

#### 자료형(Data types)

`정수형` : integer, long

`실수형` : float, double

`문자형` : char

클래스는 각각 다른 자료형으로 넣을 수 있다.



1차원 배열 선언의 예) Arr = list() Arr = [] 

2차원 배열	num = [ [1,2], [3,4], [5,6] ]

 

##### 연습문제 1 낙차 구하기

낙차가 가장 큰 상자와 크기를 구하는 문제이므로 굳이 모두 배열하고 

높이와 넓이를 따질 필요가 없다.

위에서부터 높이를 재서 비교하여 해결 가능하다.



## baby-gin game



#### 완전 검색(Exaustive Search)

해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

Brute-force 또는 generate-and-test 라고도 부름

일반적으로 경우의 수가 작을 때 유용

###### 순열

- 서로 다른 것들 중 몇 개를 뽑아서 나열
- 서로 다른 n 개 중 r 개를 선택 (nPr)



#### 탐욕(Greedy) 알고리즘

최적해를 구하는데 사용되는 근시안적인 방법

지역적으로는 최적이지만, 검증될 필요가 있다.

일반적으로 머릿속에 떠오르는 생각을 검증 없이 바로 구현하는 방법

ex) 거스름돈 문제 





## 정렬 알고리즘

2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값 혹은 그 반대의 순서로 재배열하는 것

대표적인 정렬 예)  버블 정렬, 카운팅 정렬, 선택 정렬, 퀵 정렬, 삽입 정렬, 병합 정렬

#### 키

자료를 정렬하는 기준이 되는 특정 값



### 버블 정렬

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

한자리 한자리 옮겨간 후 다시 반복하기 때문에

시간 복잡도가 O(n**2)으로 크다  (n * (n-1))



### 카운팅 정렬

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여,

선형 시간에 정렬하는 효율적인 알고리즘

- 제한 사항: 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능

  카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야한다.

  

시간 복잡도 O(n+k) : n은 리스트의 길이, k는 정수의 최대값

정렬의 안정성을 위해서 누적합을 구해서 진행한다.









































알고리즘의 4가지 패러다임







*Im 시험의 경우 리스트 보다는 인덱스를 사용하도록 하자